{"version":3,"sources":["PhotoServiceContext.js","HeaderBreadcrumb.js","AlbumsList.js","ViewPhoto.js","Modal.js","ImageModal.js","ViewAlbum.js","About.js","GooglePhotosService.js","App.js","serviceWorker.js","index.js"],"names":["context","createContext","undefined","HeaderBreadcrumb","props","className","albumDetails","title","to","AlbumsList","service","useContext","PhotoServiceContext","useState","albums","setAlbums","isLoading","setIsLoading","useEffect","loadAlbums","then","arg","newAlbums","map","obj","id","src","coverPhotoBaseUrl","alt","length","ViewPhoto","photoID","photoNumber","photosTotal","console","log","photoDetails","setPhotoDetails","loadPhotoDetail","match","baseUrl","modalRoot","document","getElementById","Modal","el","createElement","setAttribute","appendChild","removeChild","ReactDOM","createPortal","children","ImageModal","onClick","e","handleClose","ViewAlbum","albumID","params","aid","setAlbumDetails","shown","setShown","selectedPhotoID","setSelectedPhotoID","selectedPhotoNumber","setSelectedPhotoNumber","currentPageNumber","setCurrentPageNumber","currentPageToken","setCurrentPageToken","previousPageTokenArray","setPreviousPageTokenArray","handleClickShowOrHide","pid","pnumber","preventDefault","targetClassName","target","parseInt","loadAlbumDetail","result","mediaItems","mediaItem","itemIndex","href","mediaItemsCount","handleClickPrevious","Math","ceil","nextPageToken","handleClickNext","About","GooglePhotosService","gapiClient","this","photoslibrary","list","fullResponse","token","get","albumId","response","album","search","pageToken","catch","mediaItemId","SCOPE","App","initialising","setInitialising","isAuthorised","setIsAuthorised","photoService","setPhotoService","intervalId","setInterval","window","gapi","clearInterval","load","client","init","discoveryDocs","clientId","gapiID","scope","auth","auth2","getAuthInstance","isSignedIn","listen","user","hasGrantedScopes","currentUser","startAuth","onSignOut","useCallback","signOut","onSignIn","signIn","Provider","value","path","exact","component","Boolean","location","hostname","render","process","REACT_APP_GAPI_CLIENT_ID","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.7f48eb0e.chunk.js","sourcesContent":["import { createContext } from 'react';\n\nconst context = createContext(undefined);\n\nexport default context;\n","import React from 'react';\nimport { Link } from 'react-router-dom';\n\nfunction HeaderBreadcrumb(props) {\n  return (\n    <div className=\"header\">\n      <h2>\n        {props.albumDetails && props.albumDetails.title ? (\n          <Link to=\"/\">Albums</Link>\n        ) : (\n          'Albums'\n        )}\n        {props.albumDetails && props.albumDetails.title && (\n          <span>\n            &nbsp;&raquo;&nbsp;\n            {props.albumDetails.title}\n          </span>\n        )}\n      </h2>\n    </div>\n  );\n}\n\nexport default HeaderBreadcrumb;\n","import React, { useState, useEffect, useContext } from 'react';\nimport { Link } from 'react-router-dom';\nimport PhotoServiceContext from './PhotoServiceContext';\nimport HeaderBreadcrumb from './HeaderBreadcrumb';\n\nfunction AlbumsList() {\n  const service = useContext(PhotoServiceContext); // new GooglePhotosService();\n  const [albums, setAlbums] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // useEffect only runs once to get the promise data initially.\n  useEffect(\n    function () {\n      const promise = service.loadAlbums();\n      promise.then(function (arg) {\n        setAlbums(arg);\n        setIsLoading(false);\n      });\n    },\n    [service]\n  );\n\n  const newAlbums = albums.map(function (obj) {\n    return (\n      <li key={obj.id}>\n        <Link to={'/album/' + obj.id}>\n          <figure>\n            <img src={obj.coverPhotoBaseUrl} alt=\"\" />\n            <figcaption>\n              <h3>{obj.title}</h3>\n            </figcaption>\n          </figure>\n        </Link>\n        <br />\n      </li>\n    );\n  });\n\n  return (\n    <div>\n      {isLoading && 'Loading...'}\n      {albums.length > 0 && (\n        <div>\n          {/* console.log('AlbumsList albums', albums) */}\n\n          <HeaderBreadcrumb />\n\n          <ul className=\"albums\">{newAlbums}</ul>\n        </div>\n      )}\n\n      <hr />\n      <Link to=\"/\">Back to Albums List</Link>\n    </div>\n  );\n}\n\nexport default AlbumsList;\n","import React, { useState, useEffect, useContext } from 'react';\nimport PhotoServiceContext from './PhotoServiceContext';\n\nfunction ViewPhoto(props) {\n  const photoID = props.photoID; //props.match.params.pid\n  const photoNumber = props.photoNumber;\n  const photosTotal = props.photosTotal;\n  console.log('ViewPhoto -', photoID, photoNumber, photosTotal);\n\n  const service = useContext(PhotoServiceContext);\n  const [photoDetails, setPhotoDetails] = useState(undefined);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(\n    function () {\n      const promise = service.loadPhotoDetail(photoID);\n      promise.then(function (arg) {\n        setPhotoDetails(arg);\n        setIsLoading(false);\n      });\n    },\n    [props.match, service, photoID] // keep watching this for changes\n  );\n\n  return (\n    <div>\n      {isLoading && (\n        <figure>\n          <figcaption>'Loading...'</figcaption>\n        </figure>\n      )}\n      {!isLoading && photoDetails && (\n        <figure>\n          <img src={photoDetails.baseUrl} alt=\"\" />\n          <figcaption>\n            {photoNumber} of {photosTotal}\n          </figcaption>\n        </figure>\n      )}\n      {!isLoading && !photoDetails && (\n        <figure>\n          <figcaption>Photo not found</figcaption>\n        </figure>\n      )}\n    </div>\n  );\n}\n\nexport default ViewPhoto;\n","import React, { useEffect } from 'react';\nimport ReactDOM from 'react-dom';\n\n// Source: https://www.thomasmaximini.com/building-fullscreen-overlays-with-react-16-portals\n// use the same div here that I mount my app into\n// so the modal will be a sibling of the rest of the app\n// in the DOM hierachy\nconst modalRoot = document.getElementById('root');\n\nfunction Modal(props) {\n  // constructor\n  const el = document.createElement('div');\n  el.setAttribute('id', 'modal');\n\n  // Similar to componentDidMount and componentDidUpdate\n  useEffect(function () {\n    modalRoot.appendChild(el);\n\n    // Equivalent to componentWillUnmount\n    // Specify how to clean up after this effect:\n    return function cleanup() {\n      modalRoot.removeChild(el);\n    };\n  });\n\n  return ReactDOM.createPortal(props.children, el);\n}\n\nexport default Modal;\n","import React from 'react';\nimport Modal from './Modal';\n\n// props.children renders child nodes within ImageModal\nfunction ImageModal(props) {\n  return (\n    <Modal>\n      <div\n        className=\"wrapper\"\n        onClick={(e) => {\n          props.handleClose(e);\n        }}\n      >\n        {/* className={ props.shown ? '' : 'hidden' } */}\n        <div className=\"inner\">{props.children}</div>\n      </div>\n    </Modal>\n  );\n}\n\nexport default ImageModal;\n","import React, { useState, useEffect, useContext } from 'react';\nimport { Link } from 'react-router-dom';\n// import DummyGooglePhotosService from './DummyGooglePhotosService';\nimport PhotoServiceContext from './PhotoServiceContext';\nimport HeaderBreadcrumb from './HeaderBreadcrumb';\nimport ViewPhoto from './ViewPhoto';\nimport ImageModal from './ImageModal';\n\nfunction ViewAlbum(props) {\n  const albumID = props.match.params.aid;\n\n  // const service = new DummyGooglePhotosService();\n  const service = useContext(PhotoServiceContext);\n\n  const [albumDetails, setAlbumDetails] = useState(undefined);\n  const [isLoading, setIsLoading] = useState(true);\n  const [shown, setShown] = useState(false);\n  const [selectedPhotoID, setSelectedPhotoID] = useState(undefined);\n  const [selectedPhotoNumber, setSelectedPhotoNumber] = useState(undefined);\n  const [currentPageNumber, setCurrentPageNumber] = useState(1);\n  const [currentPageToken, setCurrentPageToken] = useState(undefined);\n  const [previousPageTokenArray, setPreviousPageTokenArray] = useState([\n    undefined,\n  ]);\n\n  const handleClickShowOrHide = (e, pid = undefined, pnumber = undefined) => {\n    e.preventDefault(); // cancel default behaviour of opening a link\n    const targetClassName = e.target.className; // .tagName.toLowerCase()\n\n    if (shown) {\n      if (targetClassName === 'inner' || targetClassName === 'wrapper') {\n        setShown(false);\n      }\n    } else {\n      setSelectedPhotoID(pid);\n      setSelectedPhotoNumber(parseInt(pnumber) + 1);\n      setShown(true);\n    }\n  };\n\n  /* Modal resource: https://www.thomasmaximini.com/building-fullscreen-overlays-with-react-16-portals */\n  const renderModal = () => {\n    return (\n      <ImageModal handleClose={handleClickShowOrHide} shown={shown}>\n        <ViewPhoto\n          photoID={selectedPhotoID}\n          photoNumber={selectedPhotoNumber}\n          photosTotal={albumDetails.mediaItemsCount}\n        />\n      </ImageModal>\n    );\n  };\n\n  useEffect(\n    () => {\n      const promise = service.loadAlbumDetail(albumID, currentPageToken);\n      promise.then(function (arg) {\n        setAlbumDetails(arg);\n        setIsLoading(false);\n      });\n    },\n    [props.match, service, albumID, currentPageToken] // keep watching this for changes\n  );\n\n  const handleClickNext = (e) => {\n    e.preventDefault();\n    // check if previous page token of current page exists\n    if (typeof previousPageTokenArray[currentPageNumber] === 'undefined') {\n      setPreviousPageTokenArray([...previousPageTokenArray, currentPageToken]);\n    }\n    setCurrentPageToken(albumDetails.result.nextPageToken);\n    setCurrentPageNumber(currentPageNumber + 1);\n  };\n\n  const handleClickPrevious = (e) => {\n    e.preventDefault();\n    setCurrentPageToken(previousPageTokenArray[currentPageNumber - 1]);\n    setCurrentPageNumber(currentPageNumber - 1);\n  };\n\n  return (\n    <div>\n      {isLoading && <span>'Loading...'</span>}\n      {!isLoading && albumDetails && (\n        <div>\n          <HeaderBreadcrumb albumDetails={albumDetails} />\n\n          <ul>\n            {albumDetails.result.mediaItems.map(function (\n              mediaItem,\n              itemIndex\n            ) {\n              return (\n                <li key={mediaItem.id}>\n                  <a\n                    href=\"#\"\n                    onClick={(e) => {\n                      handleClickShowOrHide(e, mediaItem.id, itemIndex);\n                    }}\n                  >\n                    <figure>\n                      <img src={mediaItem.baseUrl} alt=\"\" />\n                    </figure>\n                  </a>\n                </li>\n              );\n            })}\n          </ul>\n\n          {shown && renderModal()}\n\n          <div id=\"pagination\">\n            {currentPageToken && (\n              <span>\n                <a\n                  href=\"#\"\n                  onClick={(e) => {\n                    handleClickPrevious(e);\n                  }}\n                >\n                  Prev\n                </a>\n                &nbsp;\n              </span>\n            )}\n\n            <span>\n              {currentPageNumber} of{' '}\n              {Math.ceil(albumDetails.mediaItemsCount / 25)}\n            </span>\n\n            {albumDetails.result.nextPageToken && (\n              <span>\n                &nbsp;\n                <a\n                  href=\"#\"\n                  onClick={(e) => {\n                    handleClickNext(e);\n                  }}\n                >\n                  Next\n                </a>\n              </span>\n            )}\n          </div>\n        </div>\n      )}\n      {!isLoading && !albumDetails && <span>Album not found</span>}\n\n      <hr />\n      <Link to=\"/\">Back to Albums List</Link>\n    </div>\n  );\n}\n\nexport default ViewAlbum;\n","import React from 'react';\nimport { Link } from 'react-router-dom';\n\nfunction About() {\n  return (\n    <div>\n      This site was made with React 16.8, Google Photos API, and SASS.\n      <br />\n      <Link to=\"/\">Back</Link>\n    </div>\n  );\n}\n\nexport default About;\n","class GooglePhotosService {\n  constructor(gapiClient) {\n    this.gapiClient = gapiClient;\n  }\n\n  loadAlbums() {\n    return this.gapiClient.photoslibrary.albums\n      .list({})\n      .then(function (fullResponse) {\n        // { result: { albums } }\n        const albums = fullResponse.result.albums;\n        // Handle the results here (response.result has the parsed body).\n        return albums;\n      });\n  }\n\n  loadAlbumDetail(id, token) {\n    return this.gapiClient.photoslibrary.albums\n      .get({ albumId: id })\n      .then((response) => {\n        return response.result;\n      })\n      .then((album) => {\n        //console.log('loadAlbumDetail album', album)\n        return this.gapiClient.photoslibrary.mediaItems\n          .search({ albumId: id, pageToken: token })\n          .then(function (response) {\n            //console.log('loadAlbumDetail then response', response)\n\n            // join album data with mediaItems corresponding to album\n            return {\n              ...album,\n              result: response.result,\n            };\n          });\n      })\n      .catch(function (e) {\n        return undefined;\n      });\n  }\n\n  loadPhotoDetail(id) {\n    return this.gapiClient.photoslibrary.mediaItems\n      .get({ mediaItemId: id })\n      .then((response) => {\n        return response.result;\n      })\n      .catch(function (e) {\n        return undefined;\n      });\n  }\n}\n\nexport default GooglePhotosService;\n","/* global gapi */\nimport React, { useEffect, useCallback, useState } from 'react';\nimport AlbumsList from './AlbumsList';\nimport ViewAlbum from './ViewAlbum';\nimport About from './About';\nimport { HashRouter as Router, Route } from 'react-router-dom';\nimport PhotoServiceContext from './PhotoServiceContext';\n// import DummyGooglePhotosService from './DummyGooglePhotosService';\nimport GooglePhotosService from './GooglePhotosService';\n\nconst SCOPE = 'https://www.googleapis.com/auth/photoslibrary.readonly';\n\nfunction App(props) {\n  const [initialising, setInitialising] = useState(true);\n  const [isAuthorised, setIsAuthorised] = useState(false);\n  const [photoService, setPhotoService] = useState(undefined);\n\n  useEffect(() => {\n    console.log(\"we've mounted\");\n\n    const intervalId = setInterval(() => {\n      if (!window.gapi) {\n        return;\n      }\n\n      clearInterval(intervalId);\n      gapi.load('client:auth2', () => {\n        gapi.client\n          .init({\n            discoveryDocs: [\n              'https://photoslibrary.googleapis.com/$discovery/rest?version=v1',\n            ],\n            clientId: props.gapiID,\n            scope: SCOPE,\n          })\n          .then(function () {\n            setInitialising(false);\n\n            const auth = gapi.auth2.getAuthInstance();\n            auth.isSignedIn.listen(() => {\n              setIsAuthorised(user.hasGrantedScopes(SCOPE));\n            });\n\n            const user = auth.currentUser.get();\n            const startAuth = user.hasGrantedScopes(SCOPE);\n            setPhotoService(new GooglePhotosService(gapi.client));\n            setIsAuthorised(startAuth);\n\n            // gapi.client.photoslibrary.albums.list({})\n            //   .then(function(response) {\n            //     // Handle the results here (response.result has the parsed body).\n            //     console.log(\"Album Response\", response);\n            //   });\n          });\n      });\n    }, 100);\n  }, [props.gapiID]);\n\n  const onSignOut = useCallback(() => {\n    gapi.auth2.getAuthInstance().signOut();\n  }, []);\n\n  const onSignIn = useCallback(() => {\n    gapi.auth2.getAuthInstance().signIn();\n  }, []);\n\n  if (initialising) {\n    return <div>Initialising...</div>;\n  }\n\n  if (!isAuthorised) {\n    return <button onClick={onSignIn}>Sign in</button>;\n  }\n\n  return (\n    <div className=\"App\">\n      <PhotoServiceContext.Provider value={photoService}>\n        <Router>\n          <button onClick={onSignOut}>Sign Out</button>\n\n          <Route path=\"/\" exact component={AlbumsList} />\n          <Route path=\"/album/:aid\" component={ViewAlbum} />\n          <Route path=\"/about\" component={About} />\n        </Router>\n      </PhotoServiceContext.Provider>\n    </div>\n  );\n}\n\nexport default App;\n","/* global fetch */\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './sass/style.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App gapiID={process.env.REACT_APP_GAPI_CLIENT_ID} />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}